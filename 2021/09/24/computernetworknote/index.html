<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">



<title>计算机网络笔记（COS 109） | ming</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 5.4.0"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">ming&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>

        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">ming&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">计算机网络笔记（COS 109）</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">ming</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">September 24, 2021&nbsp;&nbsp;17:17:35</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <h2 id="编程语言-amp-计算机网络"><a href="#编程语言-amp-计算机网络" class="headerlink" title="编程语言&amp;计算机网络"></a>编程语言&amp;计算机网络</h2><hr>
<p>存在两个问题，容易看不到整体，容易被概念吓倒。 所以先从一个较高的高度整体把握。</p>
<p>主要是COS 109笔记 展露出来的是这位科学家的人文关怀和思想锋芒。</p>
<h3 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h3><p>20世纪90年代，随着因特网和万维网的发展，更多语言被开发出来。计算机处理器的速度继续加快，内存容量继续增大，而编程是否高效，是否便携变得比机器效率更重要，诸如java和JavaScript这样的语言有意做了折中处理。<br>针对某个特定的任务，总会有多种写程序的方式。从这个意义上说，编程就像是文学创作。正如写作一样，风格以及恰如其分地运用语言对写程序至关重要，而且还是区分真正伟大的程序员与普通程序员的标志。 正因为同样的计算任务可以有如此丰富的表达方式，整段代码中片段的复制和剽窃显而易见。</p>
<p>js同样是c衍生语言大家族的一员，但它与c的差别也非常大。<br>虽然所有语言在形式上都是等价的（都可以模拟图灵机），但这绝不是说它们都同等适用于所有的编程任务。写一个控制复杂网页的JavaScript程序，与写一个实现JavaScript编译器的c++程序仍有天壤之别。同时擅长这两种编程任务的程序员并不多见，经验丰富的专业程序员也可能熟悉或精通十几种语言，但他们不会对多种语言都同样熟练。</p>
<p>现在的编程语言多达几千种甚至上万种，但真正广泛使用的恐怕连100种都到不了。为什么会有这么多种？前面也提到过，每种语言都代表了对效率、表达能力、安全性和复杂性的取舍。许多语言显然是为了弥补之前语言的不足才发明的，他们不仅吸取了之前语言的教训，还能利用更多的计算资源，通常也会受到设计者个人喜好的强烈影响。新的应用领域也会催生专门面向该领域的新语言。</p>
<p>不管怎么样，编程语言都是计算机科学中一个重要而吸引人的部分。正如美国语言学家本杰明沃尔夫所说：“语言铸就着我们的思维方式，决定我们可以思考什么。” 这个论调是否适用于自然语言还有争议，但对于我们所发明的用来告诉计算机去做什么的人造语言来说，似乎很有道理。</p>
<blockquote>
<p>js这门语言实际上包含三个方面。第一是语言本身，包括让计算机完成算术计算的语句、测试条件，以及重复计算的规则等。<br>第二是js代码库，也就是由别人写好的程序段，你可以在自己的程序里直接使用这些预制程序段，而不必再花时间重写。典型的例子包括数学函数、计算日历的函数，以及搜索和操作文本的函数等。<br>第三是访问浏览器和网页的接口，这些接口含有js，js程序通过这些接口可以在其所在的网页中获得用户输入，响应用户动作(如单击按钮或填写表单）、让浏览器显示不同的内容或者切换到其他网页。</p>
</blockquote>
<p>程序中数据的类型。在内部，计算机会帮我们明确区分123这样的数值和hello这样的任意字符串。有些语言要求程序员自己谨慎地表达这种区别，而另一些语言则尝试猜测程序员的意图。js差不多就属于后一类，因此有时候明确知道数据类型以及如何解释相应的值是十分必要的。</p>
<p>编程是一种令人愉快而充实地消耗时间的方法。作为一个程序员所养成的思考和解决问题的思路在生活中的很多其他地方转换起来也很有效。</p>
<p>计算机科学，也不仅仅是编程，虽然编程在其中占了很大一部分。学术上计算机科学也包括算法和数据结构的理论及实际运用，它还包括体系结构、语言、操作系统、网络，以及计算机科学与其他内容交叉领域内的一系列应用。</p>
<p>算法就是一系列精确、无歧义的步骤，可以在执行完某些任务后停止。算法描述了不依赖于任何实现详情的计算过程。这些步骤由定义明确的基本操作或原始操作构成。</p>
<p>编程 算法是抽象的。程序是让计算机完成一个任务的所有必须步骤的具体描述。程序必须考虑内存和时间的限制、数值的大小和精度、应对偏激和恶意用户以及承受频繁的更改。</p>
<h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><p>无论从哪方面看，通信才是真正让一切变得有意思的东西。</p>
<p>电话系统把全世界的电话机连在了一起，那么如何通过计算机网络把全世界的计算机连接起来呢？怎样才能扩大网络规模，把不同的本地网络连接在一起呢？ 底层网络采用了不同的技术，不同的网络又是怎样互通的？如何从容扩展网络？</p>
<p>因特网就是应对以上所有问题的一个解决方案。实际上，由于它实在太成功了，所以在大多数情况下，它就是唯一的答案。</p>
<h4 id="因特网概述"><a href="#因特网概述" class="headerlink" title="因特网概述"></a>因特网概述</h4><p>我们需要以下机制：</p>
<ul>
<li>地址<br>IPv4（4字节） IPv6（16字节） 移动设备往往使用动态地址。</li>
<li>名字<br>域名系统（Domain Name System, DNS) 用于名字和IP地址之间的转换，是因特网基础设施的重要组成部分。</li>
<li>路由<br>解决从源地址到目标地址的路径寻找问题。 这在任何大型网络中都是核心问题所在。<br>网关就提供了这种功能。网关之间持续交换路由信息，即因特网上网络和设备的相互连接情况，并根据路由信息把收到的每个数据包转发到下一个离最终目的地更近一些的网关。<br>网络规模过于庞大，动态性较强，静态路由表无法满足要求。因此，因特网网关通过与邻近网关交换信息来刷新自身的路由信息，这样就能保证可能的及所需的路径信息基本跟得上网络的变化。<br>因特网的庞大规模要求采用分层结构来管理路由信息。在路由系统的最顶层，上万个自治系统提供了它们所包含的网络的路由信息。一个自治系统通常也对应于一个大型因特网服务提供商（isp）。在自治系统内部，路由信息仅进行本地交换，但整个自治系统对外部系统展现统一的路由信息。<br>用户通过isp接入因特网，isp之间通过网关相互连接。各个公司的网络都汇接到因特网交汇点。运营商网络之间则互相建立物理连接。 这样，就能使来自一个网络的数据高效传送到另一个网络。</li>
<li>协议<br>最后，为了使信息在不同计算机之间成功复制，必须有一些规则和步骤，用来准确描述上述机制和其他因特网组件是如何协作的。<br>因特网的核心协议称为ip，该协议为信息传输定义了统一的传输机制和通用的格式。不同类型的网络硬件用各自的协议来输送IP数据包。<br>在ip协议之上是tcp（Transmission Control Protocol,传输控制协议），该协议利用 IP 协议来提供可靠的传输机制，以便能从源地址向目标地址发送任意长度的字节序列。<br>tcp之上，更高层的协议利用tcp协议来提供那些我们看起来是因特网的服务，如网页浏览、电子邮件、文件共享等（应用层协议）。除此之外，因特网还有很多其他协议。例如，动态更改IP地址是通过DHCP 协议 (Dynamic Host Confguration Protocol，动态主机配置协议）来处理的。所有这些协议合起来就定义了因特网。</li>
</ul>
<p>接下来对一些主题进行详细探讨。</p>
<h4 id="tcp-ip"><a href="#tcp-ip" class="headerlink" title="tcp/ip"></a>tcp/ip</h4><p>协议规定了双方互相沟通时遵守约定规则。<br>网络协议精确而有针对性。<br>因特网有很多协议，其中最基础的有两个。因特网协议（internet protocol，ip）定义了单个数据包的格式和传输方式，二是传输控制协议（transmission control protocol，tcp），定义了ip数据包如何组合成数据流以及如何连接到服务。两者结合起来就叫tcp/ip。</p>
<h5 id="IP-因特网协议"><a href="#IP-因特网协议" class="headerlink" title="IP-因特网协议"></a>IP-因特网协议</h5><p>因特网协议提供的数据包传递服务是：<br>无连接：每个数据包都是独立的。<br>不可靠：字面含义。 尽力而为。<br>当然，实际使用的时候，因特网协议是相当可靠的，但是当数据包中途丢失或损坏的时候，该协议确实不会尝试修复。<br>ip协议无法对数据的流动速度做出保证：作为一个“尽力而为”型协议，它甚至无法保证数据一定到达，更别说数据的到达速度。因特网通过大量的缓存来保证数据的流动。</p>
<h5 id="TCP-传输控制协议"><a href="#TCP-传输控制协议" class="headerlink" title="TCP-传输控制协议"></a>TCP-传输控制协议</h5><p>高层协议将来自下层的不可靠服务合成可靠的通信。其中最重要的高层协议就是传输控制协议tcp。 能为用户提供可靠的双向数据流：数据从一端传达至另一端时，延迟很小，出错率很低，仿佛是一条从一头到另一头的直连线缆。<br>在TCP 中，将字节流切分成片报文段，放到TCP 数据包也就是所谓的段里。TCP 报文段不仅包含实际数据，还有控制信息构成的头部，其中包括序列号，这便于接收方了解收到的包代表数据流中的哪一部分。这样通过序列号，就可以发现丢失的段并重新传输。TCP 报文段的头部还包括错误检测信息。这样如果段受损就很容易检测出来。每个TCP报文段都放在一个IP 数据包里传输。<br>接收方必须对收到的每个报文段返回应答，确认或否认。如果在适当间隔之后还没收到应答，那就认为这个报文段已丢失，然后重新发送。同样，如果预期会收到某个特定的报文段却没收到。那就得发送否认应答（比如 “未收到 27 号报文段”），这样我就会重新发送。<br>显然，如果应答本身丢失了，情况就会更复杂。TCP 使用若干计时器来检测此类错误，计时器会设定特定的操作时间长度，超时就认为出错。如果某个操作耗时过长，就会启动恢复程序。最终，<br>某个连接可能会因为 “超时”而被终止（你也许在面对无响应网站时遇到过这种情况)。这些都是TCP 协议的一部分。</p>
<p>TCP 协议同样还包含提高传输效率的机制。比如，发送方可以在未收到上个包的应答信息时就继续发送下个包，接收方也可以对接收到的一组包只回送一个应答。在通信顺畅的时候，这样做可以降低应答带来的经常性开支。而当网络发生拥塞、开始出现丢包现象时，发送方就迅速回退到较低速率，直到缓慢地一送一答。</p>
<p>在两台计算机主机之间建立tcp连接时，不仅要指定计算机，还要指定端口。每个端口表示一个独立的会话。有一百多个众所周知的端口预留给了标准服务。比如，web服务使用80端口，邮件服务器使用25端口。</p>
<p>tcp协议实现细节远比这复杂得多，但基本原理就是这些。尽管网络规模和通信速度已经增长了多个数量级，在经历了多次改进的情况下，TCP/TP 协议还是能基本保持不变，这充分证明最初的设计是相当棒的。如今，TCP/IP处理着因特网上的大部分流量。</p>
<h4 id="高层协议"><a href="#高层协议" class="headerlink" title="高层协议"></a>高层协议</h4><p>TCP提供了可靠的双向通信方式，可使数据在两台计算机之间来回传输。因特网服务和应用程序使用TCP 作为传输机制，但在完成具体任务时还要使用自己特定的协议。例如，超文本传输协议(Hyper Text Transter Protocol， HTTP) 就是web 浏览器和服务器使用的非常简单的协议。</p>
<h5 id="telnet-amp-SSH"><a href="#telnet-amp-SSH" class="headerlink" title="telnet&amp;SSH"></a>telnet&amp;SSH</h5><p>远程登录是用来跟别的计算机建立远程登录会话的TCP服务，通常使用23端口，但也可以指定其他端口。</p>
<p>从远程登录发展而来的 SSH （ Secure Shell，安全外壳协议）广为人们使用。因为 SSH 对所有方向的数据传输加密，信息交换非常安全；它使用22端口。</p>
<h5 id="SMTP——简单邮件传输协议-Simple-Mail-Transfer-Protocol-SMTP"><a href="#SMTP——简单邮件传输协议-Simple-Mail-Transfer-Protocol-SMTP" class="headerlink" title="SMTP——简单邮件传输协议 (Simple Mail Transfer Protocol,SMTP)"></a>SMTP——简单邮件传输协议 (Simple Mail Transfer Protocol,SMTP)</h5><p>我们通常使用浏览器或者独立的程序来收发邮件，但就像因特网上的诸多其他应用一样，我们所能看到的只是表面，之下还有若千层，每层都靠各自的程序和协议来支撑。邮件的运行涉及两种基本类型的协议。SMTP 用来在不同系统之间交换邮件。具体步骤是，先建立一条连接到收件人的邮件服务器25 端口的TCP/IP 连接，使用该协议指明发件人和收件人，然后传送邮件内容。SMTP 是基于文本<br>的协议。</p>
<p>由于SMTP 要求邮件消息是 ASCII 文本，为此，MIME 标准，即多用途因特网邮件扩展 (Multipurpose Internet Mail Extension)， 描述了如何将其他类型的数据转化为文本以及如何把多块数据拼成一条邮件消息。这个机制用来在邮件里插入照片、音乐等附件，也用于 HTTP。</p>
<p>虽然 SMTP 也是端对端协议，但它的 TCP/IP 包从源节点到目标节点常常要经过 15 ～20 跳网关，这就意味着，途中的任何网关都可以检查经过的包，将邮件内容复制下来以从容不迫地审查。而且，SMTP 本身也可以复制邮件内容，邮件系统会跟踪内容和头部的传送。因此，如果不想让发送的邮件内容被别人看到，一定要从一开始就加密。但有一点要记住，加密邮件内容并不会隐藏发件人<br>和收件人的身份。同时对流量的分析可以揭露通信的双方是谁，这些元数据和具体内容一样可以提供大量信息。</p>
<p>SMTP 只是负责将邮件从源主机传送到目标邮件服务器，与用户收取邮件的方式无关。邮件到达目标邮件服务器之后就原地等待，直到被收件人取走。广泛使用的邮件接收协议是 IMAP (Internet Mail Access Protocol，因特网邮件访问协议)。IMAP 确保邮件只存在于服务器上，这样任何时候邮箱都是一致状态，而你可以从好几个地方去访问它。IMAP 保证邮箱处于恒定状态，即使多个访问者同</p>
<p>时读取邮件或对其进行刷新，比如当你在手机和浏览器上处理邮件时。这样就不需要复制多份消息，或是在计算机之间进行同步。</p>
<p>像 Gmail 这样的 “云端”邮件系统也很常见。这些系统底层也是通过 SMTP 传输邮件，客户端也像 IMAP 那样访问邮件。  </p>
<h4 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h4><p>因特网是一个由数据包构成的网络：信息被分成独立的标准化数据包传输，每个数据包都在动态路由的引导下通过不断变化的网络集合。<br>网关为ip数据包指路，或者说路由，虽然每种物理网络都有自己的ip数据包传送格式。因此网关在接收和转发它们时，必须在特定网络格式和ip之间来来回回地转换。</p>
<p>在ip层之上，tcp提供可靠的通信。这样，用户（实际上是指程序员）就不用考虑数据包，只要面对信息流就可以了。我们认为属于“因特网”的大部分服务都使用了tcp。</p>
<p>再往上一层是支撑万维网、邮件、文件传输之类服务的应用层协议，它们大多以tcp为基础进行设计。从上面对协议的描述可见，因特网协议是分好几层的，每层都依赖下一层的服务，并为上一层提供服务。</p>
<p>和tcp处在同一层的还有udp，比tcp简单得多，如果某些数据交换不要求双向流传输，只要高效的数据包投递和少量其他特性，那便使用udp。dns、流媒体视频、voip和某些在线游戏都使用了udp。</p>
<p>很多配件和设备都有强大的处理器、内存，它们也通常能够连接无线网络。</p>
<p>因特网背后只有很少的基本概念，如此少的机制却造就了如此规模的网络系统，令人惊叹（当然在这个过程中大量的工程必不可少）。</p>
<p>通信系统无所不在，它在本地和世界各处运行。重要的是理解其中的信息流动、谁能够查看这些信息，以及信息是如何得到控制的。 协议（即系统之间交换信息的规则）也非常重要。协议的特性影响深远，由今天因特网中的身份认证问题可见一斑。</p>
<p>协议将系统分层。每层协议使用更低一层提供的服务，并向较高的一层提供服务，没有哪一层是万能的。协议分层是因特网运行的基础，这是为了在隐藏实现的非相关细节的同时，组织和控制其复杂性。每层协议只负责它所会的——硬件网络将字节在网络中的计算机之间移动，IP 将独立的数据包发送至因特网的另一端，TCP从IP 处组织可靠的信息流，然后应用协议通过信息流来回传送数据。这里每一层呈现的编程接口都是很好的 API 案例。</p>
<p>“举手之劳，无不可及”曾是AT&amp;A在20世纪80年代的一句广告语，宣传效果非常好。今天，万维网、电子邮件、社交网站、云计算都可以实现这个愿景。有时候，这幅图景很美好。你可以在比以前大得多的圈子里交朋友，分享自己的兴趣爱好。然而，举手之劳也可以让你在世界面前暴露无遗，而并不是每个人都对你那么友好。 垃圾邮件、欺诈、间谍软件、病毒、监视、冒名顶替、泄漏隐私信息，甚至遗失财产，种种不幸都会接踵而来。小心谨慎才是明智之举。</p>
<h4 id="万维网"><a href="#万维网" class="headerlink" title="万维网"></a>万维网</h4><p>因特网可见的一面就是万维网，也就是我们常说的“上网”的 “网”（World Wide web， 简称 web)。虽然平常我们不怎么区分因特网和万维网，但两者其实并不相同。因特网是用于通信的基础设施，或者说基础平台，这样全世界数以百万计的计算机可以轻易地互相通信。万维网连接着提供信息和请求信息的计算机，其中提供信息的叫服务器，请求信息的叫客户机(比如我们的个人计算机)。万维网使用因特网建立连接和传送信息，并为获取其他基于因特网的服务提供界面。</p>
<p>如同许多伟大的理念一样，万维网本质上是大道至简。除了无处不在、高效、开放的底层网络必不可少外，万维网主要有以下四个组成要素。</p>
<ul>
<li>首先是 URL （Unifortn Rescource Locator， 统一资源定位待)，形http:<a target="_blank" rel="noopener" href="http://www.amazon.com，指定要访问信息的名字。">www.amazon.com，指定要访问信息的名字。</a></li>
<li>其次是 HTTP （HyperText Transter Protocol，超文本传输协议），HTTP的功能很简单，在容户机请求某个 URL 时，让服务器能够返回容户端想要的信息。</li>
<li>之后是 HTML(Hyper Text Markup Language，超文本标记语言)，描述服务器返回信息的格式（或表现形式）。HTML同样很简单，不需要什么背景知识就能掌握其基本用法。</li>
<li>最后是浏览器，即计算机上的 Chrome、 Safari、 Firefox、Internet explorer 等程序，它们通过 URL 和 HTTP 向服务器发送请求，然后读取并显示服务器返回的 HTML。</li>
</ul>
<p>浏览器可以用来在FTP服务器上下载和上传文件，同时也具备电子邮件客户端的功能。是一个具备多种客户端功能的综合性客户端软件。尽管 URL 有各种不同的写法，但它们有一个共同点，那就是 URL开头的文字，即”http:”“ftp:””file.”“mailto：〞这部分文字都表示浏览器应当使用的访问方法。可以把这部分理解为访问时使用的协议类型。</p>
<p>万维网技术的发展由万维网联盟 ( World Wide Web Consortium，间称 W3C，其网站为 w3.org）这个非营利机构控制着，至少是引导者。w3C创始人和现任主席伯纳斯-李没想过靠自己的发明赚钱，<br>而是慷慨地提出让所有人免费使用万维网，反倒是加入因特网和万维网潮流的人都托他的福，成了腰缠万贯的大富翁。</p>
<h5 id="万维网的工作原理"><a href="#万维网的工作原理" class="headerlink" title="万维网的工作原理"></a>万维网的工作原理</h5><p>相互链接的页面就叫超文本（hypertext，意思是“不光是文本”)。超文本实际上是个老概<br>念，但浏览器使它进人了每个人的日常生活。<br>假定某个链接的内容是〝W3C主页”，点击链接，浏览器就会打开一个到 w3.org 域的 80 端口的 TCP/<br>IP连接，然后发送HTTP 请求，获取 URL 中域名后面部分表示的信息。如果链接是 <a target="_blank" rel="noopener" href="http://w3.org/index.html">http://w3.org/index.html</a> ，那么请求的就是 w3.org服务器上的 index.html 文件。</p>
<p>收到请求后，w3.org 服务器首先判断接下来该怎么做。如果客户端请求获取的是服务器上已有的文件，服务器就将该文件发送回去，由客户机（也就是浏览器）显示出来。服务器返回的文本绝大多<br>数都是 HTML格式的，其中包含实际内容以及如何显示这些内容或是其格式的信息。</p>
<p>以上只是最简单的描述，实际情况往往更复杂一些。HTTP 协议规定，浏览器可以在客户机请求中增加若干附加信息。服务器返回的结果中通常也会包括指明数据长度和类型的额外信息。</p>
<p>URL 自身会对信息进行编码。URL 开头的http 是协议名，最常见的协议是 HTTP，占了很大的比例。如果留意的话，偶尔也会看到其他协议开头的 URL，比如“file”表示信息来自本机（而不是网上）<br>“ https “表示采用经过加密的安全 HTTP。</p>
<p>在…”后面的是域名，即服务器的名字。城名后面跟着斜线（/）和一串字符。这些字符串会原样传递给服务器，由服务器决定如何处置。最简单的情况是域名后什么都没有，连斜线也设有。在这种情况下，服务器将返回默认页面，比如 index.html。 如果城名后有文件名，就返回其对应文件的内容。文件名之后如果有向号，一般表示问号前面的部分是程序，服务器会运行该程序并把问号后面的部分作为参数传入。这就是服务器处理网页表单信息的一种方式。</p>
<p>比如在浏览器的地址栏里输人下面的URL:<br><a target="_blank" rel="noopener" href="http://www.bing.com/search?q-funny\+cat\+pictures">http://www.bing.com/search?q-funny\+cat\+pictures</a><br>URL 必须由有限字符集中的字符写成，这个字符集里不包含空格和除字母、数字之外的大多数字符。当需要用到字符集之外的字符时，就要先对这些字符进行编码。加号“＋”的编码占用一个位<br>置，就像这个例子中，用前面冠以百分号（％）的2个十六进制代码表示其他字符。例如 URL 片段 5%2710%22%2D6%273%22 意味着5’10”-6’3”，这里的十六进制数值 27 是一个单引号，22是双引号，2D则是减号。</p>
<h5 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h5><p>定义客户端和服务器之间交互的消息内容和步骤。</p>
<p>请求消息 </p>
<p>对什么（URI）<br>进行怎样的操作（方法  get、post） post方法时，在请求消息中除了方法和URI外，还要加上传递给应用程序和脚本的数据。</p>
<p>请求消息格式：</p>
<p>请求行 消息头 消息体</p>
<p>GET /xxx/xxx HTTP/1.1  方法 url http版本</p>
<p>第二行开始为消息头。尽管通过第一行我们就可以大致理解请求的内容，但有些情况下还需要一些额外的详细信息，而消息头的功能就是用来存放这些信息。消息头的规格中定义了很多项目，如日期、客户端支持的数据类型、语言、压缩格式、客户端和服务器的软件名称和版本、数据有效期和最后更新时间等。这些项目表示的都是非常细节的信息，因此要想准确理解这些信息的意思，就需要对 HTTP 协议有非常深人的了解。消息头中的内容随着浏览器类型、版本号、设置等的不同而不同，大多数情况下消息头的长度为几行到十几行不等。</p>
<p>写完消息头之后，还需要添加一个完全没有内容的空行，然后写上需要发送的数据。这一部分称为消息体，也就是消息的主体。不过，在使用GET 方法的情况下，仅凭方法和 URI，Web 服务器就能够判断需要进行怎样的操作，因此消息体中不需要填写任何数据。消息体结束之后，整个消息也就结束了。</p>
<p>响应消息 开头有状态码&amp;响应短语 后面是头字段和网页数据。</p>
<p>～这些东西挖深的话都可以挖得非常深。</p>
<p>HTTPS是加强型的HTTP，它对TCP/IP的双向数据都做了加密。</p>
<p>HTTP 是无状态的。无状态这个行话的意思是，HTTP 服务器不必记住所有的客户请求，只要向客户机返回了请求的页面，它就可以丢弃有关这次数据交换的全部记录。</p>
<p>感觉全程比较明显的一点，整体思路是有的，具体学习方法和落地有欠缺。 &amp;时间管理和自我把控。</p>

        </div>

        
            <section class="post-copyright">
                
                
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
            
            <a class="next" rel="next" href="/2021/09/24/webdev/">前期web开发笔记</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© ming | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
