<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">



<title>前期web开发笔记 | ming</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 5.4.0"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">ming&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>

        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">ming&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">前期web开发笔记</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">ming</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">September 24, 2021&nbsp;&nbsp;11:07:58</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <p>那些艺术专业转过来的，或者实习没找好的，这段时间付出的努力可能比你多得多，而以前的优势，如果自己不加珍惜，很容易就不再明显了。 </p>
<p>再是之前更多的可能是后台基础，前端是更要好好补的。 </p>
<p>前期基础：<br>作为计算机专业，补的是 <a target="_blank" rel="noopener" href="https://teachyourselfcs.com/">https://teachyourselfcs.com/</a> 上的课程。<br>基本上补完了，然后着重又看了下算法，以及针对自己web开发这一块补了设计模式、rest、计算机网络的知识。 有些东西本科虽然学过但是在应用中才能更好地体会。 这几天整理了一下之前的笔记，汇总了出来。</p>
<h2 id="数据结构-amp-算法"><a href="#数据结构-amp-算法" class="headerlink" title="数据结构&amp;算法"></a>数据结构&amp;算法</h2><hr>
<p>主要是普林斯顿大学算法公开课 和 the algorithm design manual<br>这里对整体梳理了一遍 （前端是否需要这些？ 学必要的部分应该就好了）<br>研究算法领域的一个令人兴奋的事情是，仍然有空间可以发现有趣和创新的算法，这些算法可以产生巨大的实际影响。<br>still much to be learned!</p>
<h3 id="他每次讲算法的思路"><a href="#他每次讲算法的思路" class="headerlink" title="他每次讲算法的思路"></a>他每次讲算法的思路</h3><p>（也是可借鉴的学习方法）<br>纯讲概念很难理解，结合一个简洁干净明了的示例，用图形、表格等多种形式可视化算法与数据结构，结合具体图像，视频，事例，就会感觉很好理解。再进一步证明分析具体的数据结构及实现代码，以及考虑算法的细节，可扩展性，包括扩展延伸思路，时间复杂度，优化方向，应用场景。</p>
<p>又：一开始介绍基础概念（API的调用方法，模型的基础特性，算法的最基本最简洁版本「去除所有不必要与繁杂的细节，简化思路与抓住模型要点，后续过了一遍后再慢慢加慢慢证明」包括引导部分的提出问题。  前面理清基础概念与思路后，后面侧重应用与实例，以及变形，进一步地加深理解。 </p>
<p>从现象看本质，将问题转为我们已知的问题。<br>基本 -&gt; 看到问题，提出优化改进 -&gt; 总结提升<br>把思考代入生活，包括不断思考更优解法与优化思路，经常有意识地去总结一些经验教训。</p>
<p>将各类问题抽象为各类算法与数据结构的应用。</p>
<blockquote>
<p>Algorithm： method for solving a problem.<br>Data structure: method to store information.</p>
</blockquote>
<p>等知道自己在做什么了，理解性能指标了，可以高效地使用一些集合库。 （这里还有js版本的算法实践，也就是具体代码练习。）主要两个链接</p>
<p><a target="_blank" rel="noopener" href="https://github.com/humanwhocodes/computer-science-in-javascript">https://github.com/humanwhocodes/computer-science-in-javascript</a><br><a target="_blank" rel="noopener" href="https://github.com/trekhleb/javascript-algorithms">https://github.com/trekhleb/javascript-algorithms</a></p>
<h3 id="Basic-Data-structure"><a href="#Basic-Data-structure" class="headerlink" title="Basic Data structure"></a>Basic Data structure</h3><p>数据结构的应用场景、区别、特性？ 为什么要这么设计？<br>Contiguous : arrays, matrices,  heaps,  hash tables.<br>Linked: lists, trees, graph adjacency lists.<br>数组 链表 是否连续存储 递归特性（both can be thought of as recursive objects) =&gt; 分治算法（divide and conquer) quick sort , binary search.  </p>
<p><strong>Data types: containers, dictionaries, priority queues.</strong></p>
<p>结构 优点（详细解释为什么有该优点） 限制 改进方向 -&gt; 会带来哪些问题  </p>
<ol>
<li><p><strong>Container</strong> (storage and retrieval of data items independent of content.)<br>(Distinguished by particular retrieve order )<br>Stack堆栈，queue队列  结合具体的语言类型和数据结构。</p>
<ul>
<li>Stacks: LIFO  push &amp; pop  when retrieval order doesn’t matter at all, such as when processing batch jobs.</li>
<li>Queues: FIFO when order is important, put/get -&gt; enqueue/dequeue  breath-first search</li>
</ul>
<p>Can be effectively implemented using either arrays or linked lists.  </p>
<br>
</li>
<li><p><strong>Dictionary</strong> (access to data items by key value or content)<br>Simple implementation: arrays and linked lists<br>More powerful: binary search trees and hash tables<br>symbol table  符号表 key-value pair abstraction</p>
<ul>
<li>binary search trees: a “linked list” with two pointers per node.<br>Diﬀerent traversal orders come from changing the position of process item relative to the traversals of the left and right subtrees. Processing the item ﬁrst yields a pre-order traversal, while processing it last gives a post-order traversal.</li>
<li>Hash table 实现符号表的另一种方法<br>hash tables: constant index look up time  in an array 例：生日 represent a large object(a key, a string, a substring) using a single number.<br>A hash table is often the best data structure to maintain a dictionary. The application of hashing go beyond dictionaries.<br>String matching via hashing  n-m+2 hash value computations 哈希函数的计算存在关联性，知道第一个O(m）后面可以依次类推。<br>具体实现方式<ul>
<li>chaining<br>represent the hash table as an array of m linked lists. Search, insertion and deletion reduce to the corresponding problem in linked lists.<br>A considerable amount of memory to pointers.</li>
<li>Open addressing (an array of elements)<br>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Priority Queues</strong><br>allow new elements to enter a system at arbitrary intervals.<br>Many algorithms process items in a specific order.<br>implementation: Unsorted array, sorted array, balanced tree, heap<br>The trick is using an extra variable to store a pointer/index to the minimum entry<br>例：使用表示为数组的堆数据结构优先级队列的基本实现（binary heap）在树上移动的方式是对索引进行计算。</p>
</li>
</ol>
<h3 id="Algorithms"><a href="#Algorithms" class="headerlink" title="Algorithms"></a>Algorithms</h3><p>Sorting 排序: mergesort quicksort heapsort<br>Searching 搜索: BST hash table<br>Graphs 图： 常见表示： 邻接链表 邻接矩阵<br>图搜索算法：<br> 广度优先搜索BFS put unvisited vertices on a queue. 最短路径<br> 深度优先搜索DFS  put unvisited vertices on a stack. 递归</p>
<p>string：<br>字符串处理 字符串排序<br>What strings are 这实际上取决于你正在使用的编程语言，不同的编程语言确实有完全不同的编程实现。<br>关注字符串基本操作的有效实现。<br>如果使用其他编程语言，最好确保在开始进行字符串处理之前知道字符串是如何实现的。（确保对性能有一个了解）</p>
<h2 id="CS基础"><a href="#CS基础" class="headerlink" title="CS基础"></a>CS基础</h2><hr>
<p>Cs61a 学会了如何写代码，如何调试代码，如何参考官方文档。<br>Cs61c&amp;csapp 如何搭建系统。<br>数据库：管理数据系统可能会很复杂，但数据库语言简单。</p>
<p>这里主要写一下学到的思考学习方法。</p>
<h3 id="建立平衡与时间管理"><a href="#建立平衡与时间管理" class="headerlink" title="建立平衡与时间管理"></a>建立平衡与时间管理</h3><p>把自己实习期间的一些点也讲清楚了。后面要做的也是，学会时间管理，以及找到适合自己的生活方式，建立平衡感。</p>
<p><strong>Manage your Time Wisely.</strong> Students struggling in 213/513 often follow a pattern where they fall behind and then try to catch up with a marathon effort just before an assignment is due. Instead, they start having health problems, skip or fall asleep in lectures, do poorly in this and other classes, and fall further behind.The key is to ​<strong>never fall behind in the first place.</strong>​ When an assignment goes out that is due on 2 weeks,that’s because we expect it to require 2 weeks of concentrated effort to complete.</p>
<p><strong>Take Care of Yourself.</strong> Do your best to maintain a healthy lifestyle this semester by eating well,<br>exercising, avoiding drugs and alcohol, getting enough sleep and taking some time to relax. This will help you ​<strong>achieve your goals and cope with stress</strong>​.</p>
<h3 id="如何问问题"><a href="#如何问问题" class="headerlink" title="如何问问题"></a>如何问问题</h3><p>还有这里讲得如何寻求帮助，如何问问题，哪一些地方是需要自己独立思考的。 （其实后续的学习方法参考这个就好了，当时也没有透彻理解这些建议吧。） 结合论语中的谈一谈，中外的思想竟然是相通的。</p>
<p>官网的concern其实就把如何问问题讲清楚了。 再结合提问的智慧<br><a target="_blank" rel="noopener" href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh\_CN.md">https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh\_CN.md</a><br>问问题，什么样的东西值得提问，讲得也特别好。（包括这里的，老师只是一个引导作用，最后还是要变成自己的） 这里就有，如何合作，如何问问题，应该澄清哪些要点，有价值和有效的交流是什么，哪些问题是好问题，哪些问题只是自己懒于思考。 包括自己在网上搜索答案时，应该看什么，应该不看什么，哪些地方必须有自己的独立思考。</p>
<p>Coaching, Assisting, and Collaborating:</p>
<pre><code>•    You may not provide electronic, verbal, or written descriptions of code or other solution information.
•    You may clarify ambiguities or vague points in class handouts or textbooks.
•    You may help others use the computer systems, networks, compilers, debuggers, profilers, code libraries, and other system facilities. 
•    You may discuss and provide general, strategic advice about an assignment. 
     Providing anything more detailed than a brief description or a block diagram is not allowed. 
     Providing any kind of code or pseudo-code is not allowed. 
     Providing explicit directions on how to assemble allowed blocks of code is forbidden.
•    You may provide suggestions of potential bugs based on high-level symptoms. 
     Code-based debugging assistance is forbidden.</code></pre><p>（工具的使用是可以的 整体概念和思维指导是可以的，具体实现需要自己思考，独立完成）</p>
<h3 id="如何学习CS"><a href="#如何学习CS" class="headerlink" title="如何学习CS"></a>如何学习CS</h3><p>学习方法也讲清楚了。 继续按这个思路来就ok。<br>Our policy is based on the following beliefs, gained through many years of experience:</p>
<p>Understanding the operation and implementation of computer systems is <strong>best learned by hands-on activities: writing, debugging, measuring, and exercising programs that expose the relevant system principles.</strong></p>
<p>Developing programs from scratch, or with limited starting code, requires using <strong>design principles and logical thinking</strong> that are much deeper than can be gained by copying and modifying an existing implementation. Making use of unauthorized sources diminishes the educational value of an assignment.</p>
<p>Although teamwork and collaboration are important real-world skills, it is important to <strong>first gain the core competencies that enable individuals to serve as effective team members.</strong> These courses are designed to teach and assess these core competencies. Unauthorized collaboration diminishes the educational experience and the reliability of our assessments.</p>
<p>Based on these principles, we provide the following guidelines on what forms of resource use, resource sharing, and collaboration are permitted in these course.</p>
<h2 id="设计模式-amp-设计原则"><a href="#设计模式-amp-设计原则" class="headerlink" title="设计模式&amp;设计原则"></a>设计模式&amp;设计原则</h2><hr>
<p>是在web开发时总是会看到提到一些点，包括后续自己选型写代码时有很多东西拿不准，这里翻了一下书，如何运用设计模式和设计原则，感觉到自己之前一直有点过度设计，想把所有的情况和兼容性都考虑进去，django和rest本来就比较重型，一些比较简单的地方其实不需要用到这么复杂的设计，后来这点改掉很多。 </p>
<p>主要是《设计模式》 和 《敏捷软件开发》<br>非常快速地翻的，当时感觉自己的工程经验不足。 大量实践后回过头来看应该会好很多。 这也是自己一直的一个思路，做中学，要用了就去学。  感觉要更多地看一些大型系统的源码，找这些概念的实例，觉得自己需要更透彻地理解&amp;应用，不然容易看了还是忘掉，记忆不深。这部分还要再深入思考。</p>
<p>MVC的主要关系还是由Observer、Composite和Strategy三个设计模式给出的。</p>
<h3 id="重构的观点"><a href="#重构的观点" class="headerlink" title="重构的观点"></a>重构的观点</h3><p>这值得我们花费时间吗？毕竟，程序已经可以完成所需的功能。我强烈推荐你经常对你所编写和维护的每一个模块进行这种重构。因此投入的时间和随后为自己和他人节省的努力相比起来是微不足道的。通过最小的努力就能够对我们的系统进行扩展和修改。要想具有这种能力，最重要的就是要保持代码的清洁。在学习原则和模式前，首先学习编写清洁的代码。<br>敏捷设计： 持续应用原则、模式以及实践来改进软件结构和可读性的过程。 致力于保持系统的设计在任何时间都尽可能的简单、整洁和富有表现力。<br>设计模式是很好的东西，它们可以帮助解决很多设计问题，但是它们的存在并不意味着必须要经常使用它们。要评估使用该模式的代价与其带来的好处。<br>考虑能够工作的最简单的事情。</p>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>应用原则消除拙劣设计。  但 仅仅因为是一个原则就无条件地遵循它是错误的，过分遵循这些原则会导致不必要的复杂性。</p>
<ul>
<li>单一职责原则（SRP） 测试驱动开发迫使分离职责。 不能迫使时， 僵化性和脆弱性 -&gt; FACADE和PROXY模式对其重构，分离职责。<br>依赖于应用程序变化的方式。（也要避免不必要的复杂性）。 仅当变化发生时，变化的轴线才具有实际意义。如果没有征兆，那么应用SRP或者任何其他原则都是不明智的。</li>
<li>开放关闭原则（OCP）  对扩展开放，对修改关闭。 软件实体（类、模块、函数等）应该是可以扩展的，但是不可修改。 把其应用限定在可能会发生的变化上。对程序中呈现出频繁变化的部分进行抽象。 背后的主要机制： 抽象（abstraction） &amp; 多态 （polymorphism）。</li>
<li>里氏替换原则（LSP）<br>子类型必须能替换掉它们的基类型。<br>模型的有效性只能通过它的客户程序来表现。<br>总是保证子类可以代替它的基类是一个有效的管理复杂性的方法。一旦放弃了这一点，就必需要单独来考虑每个子类。</li>
<li>依赖倒置原则（DIP）<br>如果高层模块独立于低层模块，那么高层模块就可以非常容易地被重用。该原则是框架（framework）设计的核心原则。</li>
<li>接口隔离原则（ISP）<br>客户端程序应该仅仅依赖于它们实际调用的方法。</li>
</ul>
<p>思考设计是重要的。但是，以小步、增量的方式思考设计则是至关重要的。考虑得太多要比考虑得太少更为糟糕。<br>大型系统的设计非常依赖于好的组件设计。</p>
<h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><p>在和他人交流以及帮助解决设计问题方面，图示是最为有用的。重要的一点是，图示的详细程度应该只是达成目标所必需的。你可以绘制具有大量装饰的图示，但那是损害生产力的做法。请保持图示简单、干净。UML图不是源代码，不应该当作声明所有方法、变量和关系的地方。<br>UM是一个工具，不是最终结果。作为一个工具，它可以帮助你思考和交流设计。如果少量使用，它会带给你巨大的好处。如果过度地使用，它会浪费你大量的时间。当使用UML时，少即是好。</p>
<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p>好的文档对于任何项目都是必不可少的。缺少了它们，团队就会迷失在代码的海洋中。另一方面，具有大量错误的文档则更槽糕，因为即使你具有了所有这些造成混乱和误导的纸张，你仍迷失在代码的海洋中。</p>
<p>文档必须得编写，但是必须得慎重编写。对于什么不需要文档化的选择和什么需要文档化的选择一样重要。复杂的通信协议需要文档化。复杂的关系模型需要文档化。复杂的可重用框架需要文档化。但是，所有这些东西都不需要数百页的UMI图。软件文档应该简明扼要。软件文档的价值和多少成反比。</p>
<p>对于一个工作在一百万行代码上的12人项目团队来说，我会把需要持久保持的文档总页数控制在25~200，我偏爱少一些的页数。这些文档包括了重要模块高层结构的UML图、关系模型的ER（实体联系）图、一两页的系统构建说明、测试指导、源码控制指导等等。我会把这些文档放到wiki或者一些协作式写作工具中，这样团队中的每个人都可以在屏幕上浏览，并在需要时进行搜索和更改。<br>需要投入大量的工作才能把文档变小，不过这些工作是值得的。人们会去阅读小的文档，而不愿意去阅读1000页的大部头，</p>
<p>这里还读了一些程序员思维的书。 《黑客与画家》超级多特别有意思的观点， 还有软件沉思录，看他们如何看问题是一件有趣的事。 </p>
<h2 id="REST笔记"><a href="#REST笔记" class="headerlink" title="REST笔记"></a>REST笔记</h2><hr>
<p>模块化开发  封装库封装方法</p>
<p>现代的web应用，大多使用REST API + SPA的设计，SPA端使用Angular等框架，自己渲染HTML，REST API只提供数据服务，前端后端通过JSON数据来交流，从而实现了前后端的彻底解耦。<br>http标准足以描述所有与web资源的交互，唯一要做的就是仔细考虑资源的设计。<br>把任何动作映射到统一接口上。</p>
<p>rest 设计原则 把需求转换成一个个资源（任何值得作为超链接目标的事物）。<br>面向资源的架构（ROA） 把应用的数据划分为资源的集合。</p>
<p>功能成分： 资源、资源名称、资源的表示、资源间的链接</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ol>
<li>可寻址性 （直接输入url进入特定状态）</li>
<li>无状态性（不须经历之前的状态再到特定状态）</li>
<li>连通性<br>如果服务只是提供反映资源当前状态的系列化的数据结构，那么当然你还要开始考虑其他的标准约定，因为表示（representation）只完成一半工作<br>为什么？因为整体架构还缺少内容，超媒体描述和连通性<br>不过连通性之所以重要还有一个原因，他令客户端可以处理会不断变化的关系，链接不仅隐藏了如何为给定资源构造url的规则，还体现了资源如何互相连接的规则（相互关联）<br>有时，表示（representation）就是序列化的数据结构（serialized data structure）</li>
<li>统一接口<br> 通过对已有url发送 http get/put/post/delete对资源进行操作（在前端时进行一些设计考虑）关键在于统一性，即每个服务都以同样的方式使用http接口。<br> ROA原则和统一接口可以表达一个相当强大和复杂的分布式服务</li>
</ol>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>ROA 只是施加一些设计上的约束，而不为你的设计做出所有决定。以 REST 式和面向资源的方式来设计一个地图服务，还可以有多种其他方式。这完全依赖于你如何把数据划分为数据集、你为这些资源定义什么样的表示，以及你如何把它们跟超媒体结合起来。<br>在设计真实的服务时，还需要考虑实现(implementation）的问题。需要编写代码来实现你的想法：暴露什么资源、暴露什么样的统一接口、采用什么样的 URI，以及提供和接受什么样的表示。<br>django等都使得“暴露具有统一接口的资源”变得容易。所以要去利用。<br>编程时重要的一点 抽象思维<br>把搜索操作的结果（比如“地球上称为斯普林菲尔德的地点”）也作为数据集的一部分，而在面向 RPC 的分析中，它会被视为将被客户端调用的动作 (action)。想想 Google SOAP 服务里的doGoogleSearch。拿它跟 Google 网站作个比较：在面向资源的分析里，查找数据这个操作本身就是数据。假如你把一个算法的输出看作一个资源的话，那么要执行该算法，就只要向该资源发送 GET 请求就行了。</p>
<p>读写资源：<br>1.规划数据集<br>2.把数据集划分为资源<br>对于其中每种资源：</p>
<ol>
<li>用 URI 为该资源命名</li>
<li>暴露一个统一接口的子集</li>
<li>设计来自客户端的表示</li>
<li>设计发给客户端的表示</li>
<li>用超链接和表单把该资源与已有资源联系起来</li>
<li>考虑有哪些典型的事件经过</li>
<li>考虑可能出现哪些错误情况</li>
</ol>
<p>现在每个字段要求入库，出现的一个问题，如何设计数据库及其对应的层级URL？<br>可以把数据库render为json，对应到链接中去 一个外键，可以解决，就像results连接到user。</p>
<p>示例：通过少量代码达到展示其背后概念的目的。<br>框架的选择总会对设计产生一定影响，这是无法避免的。</p>
<p>可以从中清楚地看到 REST 式服务的主要优点：采用HTTP 方法可以使操作名称从 URI中消失，这使得 URI 能够在面向对象的意义上来标识对象。你可以通过采用不同的 HTTP方法、来对对象执行不同操作。你不必理解那些自主命名的方法，相反，你只需理解一个具有标准接口的（面向对象的意义上的）类。</p>
<p>具体到Django中：</p>
<p>在url中定义路径 在views类中定义接收http方法</p>
<p>每个rest式面向资源的web服务都使用url来标识资源，都用http统一接口来表达操作。通用性 把有关http访问的细节隐藏在接口背后。（如get，类的继承等）</p>

        </div>

        
            <section class="post-copyright">
                
                
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2021/09/24/computernetworknote/">计算机网络笔记（COS 109）</a>
            
            
            <a class="next" rel="next" href="/2021/09/06/intern-review/">intern review</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© ming | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
